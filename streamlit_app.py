# -*- coding: utf-8 -*-
"""A*_final_streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o0Kh1PtWCYJaJtqkIT9RgS0umuyO_WGp
"""

import streamlit as st
import pandas as pd
import heapq
import networkx as nx
import matplotlib.pyplot as plt
from collections import defaultdict

# Load dataset
@st.cache_data
def load_data():
    file_path = 'Updated_career_dataset.csv'
    return pd.read_csv(file_path)

df = load_data()

# Build Graph
def build_graph_from_dataset(df):
    G = {}
    for _, row in df.iterrows():
        path = [
            f"Group={row['Group']}",
            f"Math={row['Math_Score']}",
            f"Tech={row['Tech_Interest']}",
            f"Creativity={row['Creativity']}",
            f"Experience={row['Experience']}",
            f"Career={row['Career']}"
        ]
        for i in range(len(path) - 1):
            src = path[i]
            dst = path[i + 1]
            if src not in G:
                G[src] = []
            if dst not in [n for n, _ in G[src]]:
                G[src].append((dst, 1))
    return G

# Heuristic
def build_heuristics(G, user_input):
    H = {}
    for node in G:
        if node.startswith("Career="):
            H[node] = 0
        else:
            key, value = node.split('=')
            H[node] = 0 if user_input.get(key) == value else 2
    return H

# A* search
def a_star_search(graph, heuristics, start_node, goal_prefix="Career="):
    frontier = []
    heapq.heappush(frontier, (0, start_node, []))
    visited = set()

    while frontier:
        f_score, current, path = heapq.heappop(frontier)
        path = path + [current]

        if current.startswith(goal_prefix):
            return path, f_score

        if current in visited:
            continue
        visited.add(current)

        for neighbor, cost in graph.get(current, []):
            g = len(path)
            h = heuristics.get(neighbor, 1)
            f = g + h
            heapq.heappush(frontier, (f, neighbor, path))

    return None, None

# Recommendations
def get_top_recommendations(df, user_input, num_recommendations=3):
    recommendations = defaultdict(int)
    similar_users = df[
        (df['Group'] == user_input['Group']) &
        (df['Math_Score'] == user_input['Math_Score'])
    ]
    for career in similar_users['Career']:
        recommendations[career] += 1
    sorted_recommendations = sorted(recommendations.items(), key=lambda x: x[1], reverse=True)
    return [career for career, _ in sorted_recommendations[:num_recommendations]]

# Initialize Session State Properly
if 'reset' not in st.session_state:
    st.session_state['reset'] = False

# If reset button was clicked, clear fields
if st.session_state['reset']:
    st.session_state['group'] = ""
    st.session_state['math'] = ""
    st.session_state['tech'] = ""
    st.session_state['creativity'] = ""
    st.session_state['experience'] = ""
    st.session_state['reset'] = False  # Reset flag off

# App UI
st.title("üîç A* Career Path Recommendation System")

col1, col2 = st.columns(2)

with col1:
    group = st.selectbox("Select Group", options=[""] + sorted(df['Group'].unique()), key='group')
    math = st.selectbox("Select Math Score", options=[""] + sorted(df['Math_Score'].unique()), key='math')
    tech = st.selectbox("Select Tech Interest", options=[""] + sorted(df['Tech_Interest'].unique()), key='tech')

with col2:
    creativity = st.selectbox("Select Creativity", options=[""] + sorted(df['Creativity'].unique()), key='creativity')
    experience = st.selectbox("Select Experience", options=[""] + sorted(df['Experience'].unique()), key='experience')

# Find Career Path
if st.button("Find Career Path"):
    if "" in [group, math, tech, creativity, experience]:
        st.warning("‚ö†Ô∏è Please select all fields before submitting.")
    else:
        user_input = {
            'Group': group,
            'Math_Score': math,
            'Tech_Interest': tech,
            'Creativity': creativity,
            'Experience': experience
        }

        G = build_graph_from_dataset(df)
        H = build_heuristics(G, user_input)
        start_node = f"Group={group}"
        path, cost = a_star_search(G, H, start_node)

        if path:
            st.success("üéØ Career Recommendation Path Found:")
            for step in path:
                st.write("‚Üí", step)

            st.info(f"üßÆ **Total Path Cost:** {cost}")

            # Graph visualization
            Gviz = nx.DiGraph()
            for i in range(len(path) - 1):
                Gviz.add_edge(path[i], path[i + 1])

            plt.figure(figsize=(12, 6))
            pos = nx.spring_layout(Gviz, seed=42)
            nx.draw(Gviz, pos, with_labels=True, node_color='lightblue', node_size=3000,
                    font_size=10, font_weight='bold', edge_color='gray')
            plt.title("Decision Path to Career")
            st.pyplot(plt)

            # Recommendations
            recommendations = get_top_recommendations(df, user_input)
            st.markdown("### üí° Top Career Recommendations:")
            for i, rec in enumerate(recommendations):
                st.write(f"{i+1}. {rec}")
        else:
            st.error("‚ùå No career path found. Please try different inputs.")

# Reset Button with Loading Effect
if st.button("Reset"):
    with st.spinner('üîÑ Resetting your selections...'):
        st.session_state['reset'] = True
        st.rerun()


