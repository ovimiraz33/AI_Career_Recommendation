# -*- coding: utf-8 -*-
"""A*_final_streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1o0Kh1PtWCYJaJtqkIT9RgS0umuyO_WGp
"""

import pandas as pd
import networkx as nx
import matplotlib.pyplot as plt
import streamlit as st
import heapq  # For A* Search

# Load the dataset (make sure you have the correct path to the dataset)
dataset_path = 'final_career.csv'  # Replace this with your actual path if needed
df = pd.read_csv(dataset_path)

# Define a class for the nodes in the A* search
class Node:
    def __init__(self, career, cost, heuristic):
        self.career = career
        self.cost = cost  # g(n) - The actual cost to reach the node
        self.heuristic = heuristic  # h(n) - The estimated cost from the node to the goal
        self.f = self.cost + self.heuristic  # f(n) = g(n) + h(n)
    
    def __lt__(self, other):
        return self.f < other.f

# Function to calculate heuristic (h)
def calculate_heuristic(user_input, career):
    # Define heuristics based on user's input (simplified for now)
    heuristic = 0
    if user_input['Math_Score'] == 'High' and 'Engineer' in career:
        heuristic += 1
    if user_input['Tech_Interest'] == 'Yes' and 'Engineer' in career:
        heuristic += 1
    if user_input['Experience'] in ['2 years', '3 years'] and 'Artist' in career:
        heuristic += 1
    return heuristic

# Function to calculate the cost (g)
def calculate_cost(user_input, career):
    # Define cost based on how well the user matches the career (simplified for now)
    cost = 0
    if user_input['Group'] in career:
        cost += 1
    if user_input['Math_Score'] in career:
        cost += 1
    if user_input['Experience'] in career:
        cost += 1
    return cost

# A* search function
def astar_search(user_input, career_choices):
    open_list = []
    closed_list = set()
    
    # Add start node for each career
    for career in career_choices:
        heuristic = calculate_heuristic(user_input, career)
        cost = calculate_cost(user_input, career)
        node = Node(career, cost, heuristic)
        heapq.heappush(open_list, node)
    
    # Process the open list and find the best career
    while open_list:
        current_node = heapq.heappop(open_list)
        
        if current_node.career not in closed_list:
            closed_list.add(current_node.career)
            if current_node.f == 0:  # We have found the best career
                return current_node.career
        
        # Continue exploring the neighbors (for a real A* search, this would involve expanding nodes)
    
    return "No valid career found"  # If no career matches

# Streamlit UI for user input
st.title('Career Recommendation System')

# Streamlit input fields
group = st.selectbox('Select Group', ['Science', 'Commerce', 'Humanities'])
math_score = st.selectbox('Select Math Score', ['High', 'Medium', 'Low'])
creativity = st.selectbox('Select Creativity', ['High', 'Medium', 'Low'])
experience = st.selectbox('Select Experience', ['No experience', '1 year', '2 years', '3 years', '4 years', '5 years'])
tech_interest = st.selectbox('Select Tech Interest', ['Yes', 'No'])
location = st.selectbox('Select Location Preference', ['Urban', 'Rural'])
salary_expectation = st.selectbox('Select Salary Expectation', ['Low', 'Medium', 'High'])
education_level = st.selectbox('Select Education Level', ['Undergraduate', 'Postgraduate'])
communication_skills = st.selectbox('Select Communication Skills', ['Good', 'Poor'])

# Button to get recommendation
if st.button('Get Career Recommendation'):
    user_input = {
        'Group': group,
        'Math_Score': math_score,
        'Creativity': creativity,
        'Experience': experience,
        'Tech_Interest': tech_interest,
        'Location': location,
        'Salary_Expectation': salary_expectation,
        'Education_Level': education_level,
        'Communication_Skills': communication_skills
    }
    
    # Define career choices (these can be extracted from the dataset)
    career_choices = ['Engineer', 'Research Scientist', 'Programmer', 'Artist', 'Journalist', 'Content Writer', 'Sales Manager', 'Career Consultant']

    # Run the A* search algorithm
    recommended_career = astar_search(user_input, career_choices)

    st.write(f"Recommended Career: {recommended_career}")

    # Decision path visualization
    path = [(user_input['Group'], recommended_career)]
    G = nx.DiGraph()
    for i in range(len(path)-1):
        G.add_edge(f"{path[i][0]}={path[i][1]}", f"{path[i+1][0]}={path[i+1][1]}")
    G.add_edge(f"{path[-1][0]}={path[-1][1]}", f"Career={recommended_career}")

    # Plot the graph
    fig, ax = plt.subplots(figsize=(10, 6))
    pos = nx.spring_layout(G, seed=42)
    nx.draw(G, pos, with_labels=True, node_size=3000, node_color='skyblue', font_size=10, font_weight='bold', edge_color='gray', ax=ax)
    plt.title(f"A* Path to Career: {recommended_career}", fontsize=14)
    st.pyplot(fig)

